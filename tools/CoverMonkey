#!/usr/bin/env node
// -*- mode: javascript; -*-
//
// Copyright (c) 2011 The Mozilla Foundation.
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//
//     Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Contributor(s): David Flanagan (dflanagan@mozilla.com)
//                 Donovan Preston (dpreston@mozilla.com)

//
// TODO:
//
// Support @line comments.
//
// The dead code analysis is saying that catch blocks are unreachable.
// I think they must be their own entry points.  Need to ask someone on #jsapi
//   I've filed a patch for spidermonkey that will make -D associate the
//   offset of the catch with each try.  If accepted, this problem will 
//   go away.  If not, I'll have to be more creative to figure out where
//   the catch block is.
// 

var assert = require("assert");
var fs = require("fs");
var path = require("path");
var console = require("console");
var util = require("util");

const VERSION = "0.1";

function usage(code) {
    var done = process.stdout.write(
"Usage: CoverMonkey [options]\n" +
"\n" +
"    CoverMonkey reads the output generated by SpiderMonkey's -D option\n" +
"    (supported by debug builds of SpiderMonkey only) and analyzes it to\n" +
"    detect dead code and report code coverage.\n" +
"\n" +
"    CoverMonkey reads -D data from stdin by default. Use the -d option\n" +
"    to make it read from a file instead.\n" +
"\n" +
"    CoverMonkey writes basic code coverage statistics to stdout.\n" +
"    Use -q, -p and -l to modify the information displayed.\n" +
"\n" +
"    CoverMonkey can generate an HTML file that annotates and colors your \n" +
"    source code to highlight uncovered and dead code and indicate how\n" +
"    many times each line executed.  Use the -h, -a, and -b options to \n" +
"    control HTML generation.\n" +
"\n" +
"    By default, CoverMonkey will output coverage information for all \n" +
"    source files that were run. Use one or more -t options to specify\n" +
"    which files CoverMonkey should analyze.\n" +
"\n" +
" Options:\n" +
"\n" +
"    -d <file> Read -D data from the specified file instead of stdin\n" +
"\n" +
"    -t <file> Analyze coverage for the specified target file.\n" +
"              Multiple -t options are allowed.\n" +
"\n" +
"    -q        Quiet: don't display any output to stdout\n" +
"\n" +
"    -p        Percent: only display coverage percentage\n" +
"\n" +
"    -l        List the line numbers of all uncovered lines\n" +
"\n" +
"    -h <file> Output annotated source code, in HTML format, to the \n" +
"              specified file.\n" +
"\n" +
"    -a        Include assembly code for each line in the HTML file.\n" +
"              This may be useful for understanding partially-covered\n" +
"              lines.\n" +
"\n" +
"    -b        Automatically launch a browser window to display the\n" +
"              HTML. If no -h option, writes HTML to a temporary file.\n" +
"              This option may only work on MacOS.\n" +
"\n" +
"    -v        Display the CoverMonkey version number and exit\n" +
"\n" +
"    --help    Display this message and exit\n" +
""
    );

    if (done) process.exit(code);
    else process.stdout.on('drain', function() { process.exit(code); });

}


// Loop through the command-line arguments collecting input files and options
var options = {
    input: null,
    quiet: false,     // quiet: don't write to stdout
    percent: false,   // percents: only output coverage %
    listlines: false, // list individual uncovered lines
    targets: [],      // Which js files do we want stats on?
    htmlfile: null,
    overwrite: false,
    openhtml: false,  // automatically open the html file in a browser?
    outputops: false,
};


process.argv.shift();  // throw away the path to node
process.argv.shift();  // throw away the path to this script

while(process.argv.length) {
    var arg = process.argv.shift();
    switch(arg) {
    case '--help':
        usage(0);
        break;
    case '-v':
        console.log(VERSION);
        process.exit(0);
        break;
    case '-d':
        if (!process.argv.length || options.inputfile) usage(1);
        options.input = fs.createReadStream(process.argv.shift(),
                                            { encoding: "utf8"});
        break;
    case '-q':
        options.quiet = true;
        break;
    case '-p':
        options.percent = true;
        break;
    case '-l':
        options.listlines = true;
        break;
    case '-t':
        if (!process.argv.length) usage(1);
        options.targets.push(process.argv.shift());
        break;
    case '-h':
        if (!process.argv.length) usage(1);
        if (options.htmlfile) usage(1); // only specify one
        options.htmlfile = process.argv.shift();
        break;
    case '-f':
        options.overwrite = true;
        break;
    case '-b':
        options.openhtml = true;
        break;
    case '-a':
        options.outputops = true;
        break;
    default: 
        console.log("Unexpected argument: %s", arg);
        usage(1);
        break;
    }
}

// If no input file was specified, then read text from standard in
if (!options.input) {
    process.stdin.resume();
    process.stdin.setEncoding('utf8');
    options.input = process.stdin;
}

// Collect the coverage information, then analyze and report it
parseScripts(options.input, analyzeAndReportCoverage);

// The rest of this file is supporting classes and functions, etc.
const SCRIPT_START = /^--- SCRIPT ([^:]+):(\d+) ---$/;
const SCRIPT_END = /^--- END SCRIPT/;
const SCRIPT_DATA = /^(\d+):(\d+)\/(\d+)\/(\d+)\s+x\s+(\d+)\s+(.*)$/;

var Script = (function() {
    /*
     * Parse an array of lines to create a Script object.
     * "Script" is used in the SpiderMonkey internals sense: it is the body
     * of a JS function or the JS toplevel code, or an eval string.
     * 
     * Scripts have a name which is a (hopefully) unique id that includes the
     * source filename and starting line number. That isn't enough to be unique
     * because in "function a() { function b() {}}" both scripts have the same
     * file and line number. So I also have to include the ending line number
     * and/or ending opcode in the script name.  I could also include some kind
     * of hashcode of the script's opcodes in the name.  Or just use the
     * entire script disassembly as the name, I suppose.
     * 
     * XXX: Am I ever going
     * to be able to disambiguate functions a and b in the following, though?
     *   function() { function a(){} function b(){} }
     * 
     * Scripts also have a filename property that gives their filename
     * 
     * In addition to their name, scripts also have an array of opcodes and
     * a map of pc addresses to opcode indexes.
     *
     * Finally, each script has an entry point: the index of the starting opcode.
     * 
     * Each opcode includes its string of assembly code.  
     * And, after the script is analyzed, each opcode will also have a
     * reachable flag to indicate if it can ever actually be executed.
     */
    function Script(lines) {
        var script = this;
        script.opcodes = [];
        script.pcToOpcodeIndex = {};

        lines.forEach(function(dataline) {
            var match;

            if (match = dataline.match(SCRIPT_START)) {
                script.filename = match[1]; 
                script.startline = parseInt(match[2], 10);
                script.name = match[1] + ":" + match[2];
            }
            else if (dataline.match(SCRIPT_END)) {
                return;
            }
            else if (dataline === "main:") {
                script.entrypoint = script.opcodes.length;
            }
            else if (match = dataline.match(SCRIPT_DATA)) {
                var opcode = {
                    pc: parseInt(match[1], 10),
                    count: parseInt(match[2], 10) +
                        parseInt(match[3], 10) +
                        parseInt(match[4], 10),
                    srcline: parseInt(match[5], 10),
                    assembly: match[6]
                };

                // Discard the (potentially very long) anonymous function 
                // souce associated with lambda opcodes
                if (opcode.assembly.match(/^lambda /))
                    opcode.assembly = "lambda";
                if (opcode.assembly.match(/^deflocalfun /))
                    opcode.assembly = "deflocalfun";

                script.pcToOpcodeIndex[opcode.pc] = script.opcodes.length;
                script.opcodes.push(opcode);
            }
            else if (dataline[0] === '\t') {
                // this is part of a switch (or other?) disassembly
                // for the previous opcode, so append it there
                script.opcodes[script.opcodes.length-1].assembly += dataline;
            }
            else {
                // Just ignore lines that we don't recognize.
                // We have to do this because some opcodes like lambda and
                // deflocalfun print out long function bodies on multiple lines
                return;
            }
        });
    }

    // Return a verbose representation of a script.  Distinct scripts will
    // always return distinct strings. (Except in the case of identical functions
    // on the same source line.)
    Script.prototype.toString = function() {
        var s = this.name + ":" + this.entrypoint + "\n";
        var ops = this.opcodes.map(function(opcode) {
            return opcode.pc + ":" + opcode.srcline + ":"+ opcode.assembly;
        });
        return s + ops.join("\n");
    }


    // Add the opcode counts from that script to the opcodes in this script.
    // This method requires that this.equals(that)
    Script.prototype.addCounts = function(that) {
        for(var i = 0; i < this.opcodes.length; i++)
            this.opcodes[i].count += that.opcodes[i].count;
    };

    var switches = {
        "tableswitch":true,
        "lookupswitch":true,
        "tableswitchx":true,
        "lookupswitchx":true,

    };

    var terminators = {
        "stop": true,
        "return": true,
        "throw": true,
        "retrval":true,
        // treat retsub as a terminator because I treated gosub as a conditional
        "retsub":true
    };

    var unconditionals = {
        "goto": true,
        "gotox":true,
        "default":true,
        "defaultx":true, 
        "filter": true // E4X opcode: we'll probably never see it
    };

    var conditionals = {
        "ifeq": true,
        "ifeqx": true,
        "ifne": true,
        "ifnex": true,
        "or":true,
        "orx":true,
        "and":true,
        "andx":true,
        // Treat gosub as a conditional because when it
        // returns the following opcode is reachable
        "gosub":true,
        "gosubx":true,
        "case":true,   
        "casex":true,  
        "ifcantcalltop":true,
        // E4X opcode: we'll probably never see it
        "endfilter": true,

        // I treat the try opcode as a conditional as well even though it isn't
        // With my patched spidermonkey, -D outputs try opcodes with the offset
        // of the corresponding catch block, if there is one.  If the try
        // is reachable, then the catch block is reachable, too, and treating
        // it like a conditional jump is an easy way to handle it.  Note, 
        // however, that some try opcodes (like try/finally) won't have an
        // offset.  So if the offset is missing for any conditional, I'll just
        // treat it as if it falls through.
        "try": true,
    };

    // All opcodes that don't just go on to the next one
    var nonlinear = {};
    var p; for(p in terminators) nonlinear[p] = terminators[p];
    for(p in switches) nonlinear[p] = switches[p];
    for(p in conditionals) nonlinear[p] = conditionals[p];
    for(p in unconditionals) nonlinear[p] = unconditionals[p];

    function linear(op) { return !(op in nonlinear); }

    function reachable(script, opcodeIndex) {
        var opcode, op;
        opcode = script.opcodes[opcodeIndex];
        opcode.entrypoint = true; // execution can jump to here

        while(opcodeIndex < script.opcodes.length) {
            // If this opcode is already marked as reachable, then
            // we've already been here and we're done.
            if (opcode.reachable) return;
            
            // Mark this opcode as reachable.
            opcode.reachable = true;

            // Get the name of this opcode
            op = opcode.assembly.match(/(\w+)/)[1];

            // If this opcode is not a linear one, then break
            // of the loop and handle it in the code below
            if (!linear(op)) break;

            // Mark this opcode as a linear one
            opcode.fallsthrough = true;

            // And move on to the next opcode
            opcode = script.opcodes[++opcodeIndex];
        } 

        if (opcodeIndex >= script.opcodes.length) return;

        // Now the current opcode is non-linear, so recurse to
        // mark the opcodes that are reachable from it.  For
        // conditional branches, it will be the next opcode plus
        // the branch target.  For unconditional it will just be
        // the branch target.  For switches, there will be many.
        // And for things like stop, return and throw, there will
        // be no reachable opcodes.
        
        if (op in terminators) {
            // This opcode makes the script exit, so nothing is 
            // reachable from here.
            return;
        }
        else if (op in unconditionals) {
            // The unconditional jump target is reachable
            reachable(script, branchIndex(opcode.assembly));
        }
        else if (op in conditionals) {
            // The next opcode and the jump target are both reachable
            reachable(script, opcodeIndex+1);
            // If there is a branch address, then that is reachable, too.
            // (I have to test this since I'm treating try opcodes as
            // branches, and they don't always have offsets)
            var branch = branchIndex(opcode.assembly)
            if (branch) reachable(script, branch);
        }
        else if (op in switches) {
            // Multiple opcodes are reachable
            // The -D output for switches includes relative jump offsets
            // not absolute ones like those used by jumps

            // Each case is on its own line, starting with the 2nd line
            // The default offset is on the first line after the string "ffset"
            var cases = opcode.assembly.split("\t");

            var offset = parseInt(cases[0].match(/ffset (\d+)/)[1], 10);
            var absolute = opcode.pc + offset;
            var index = script.pcToOpcodeIndex[absolute];
            reachable(script, index);

            for(var i = 1; i < cases.length; i++) {
                offset = parseInt(cases[i].match(/: (\d+)$/)[1], 10);
                absolute = opcode.pc + offset;
                index = script.pcToOpcodeIndex[absolute];
                reachable(script, index);
            }
        }

        function branchIndex(assembly) {
            var match = assembly.match(/^\w+\s+(\d+)/);
            if (!match) return null;
            return script.pcToOpcodeIndex[match[1]];
        }
    }

    Script.prototype.checkReachability = function() {
        // Mark the entry point of the script as reachable, and
        // from there recursively determine what else is reachable.
        // Note that this code treats 0 as the entry point, even when
        // this.entrypoint is something else.  Before this.entrypoint
        // we get things like defvar opcodes that just fall through to the
        // entrypoint.  If we start at this.entrypoint then sometime we'll
        // have opcodes marked unreachable that we don't want marked that way.
        reachable(this, 0);
    };

    return Script;
}());

var Line = (function() {

    function Line(file, number) {
        this.file = file;
        this.number = number;
        this.opcodes = {};  // Map pc to Opcode object
    }

    Line.prototype.addOpcode = function(pc, opcode) {
        if (this.opcodes[pc]) {
            console.log("Ignoring duplicate opcode");
            return;
        }
        this.opcodes[pc] = opcode;
    };

    // Return an array of the counts for this line.  If all opcodes have
    // the same count, then this will be a single element array.  If the line
    // includes a branch then there will be multiple elements.  The counts will
    // be sorted from fewest to most.
    // If all opcodes are unreachable, then the returned array will be empty
    // indicating that the line is dead code.
    // Unreachable opcodes have a count of -1
    Line.prototype.counts = function() {
        if (!this._counts) {
            var min = Infinity, max = 0;
            var rawcounts = [];
            var lastopcode;

            for(var pc in this.opcodes) {
                var opcode = this.opcodes[pc];
                var c = opcode.count;
                if (opcode.reachable) {

                    // If the last opcode continues unconditionally on to this 
                    // one then skip this opcode if the count is the same (it 
                    // might be different if this one is also a jump target).
                    // And also skip this opcode if it has a zero count and
                    // the last one did not: that is just the sign of an
                    // interpreter optimization that messes up the counts
                    if (lastopcode && lastopcode.fallsthrough &&
                        ((c === lastopcode.count) ||
                         (c === 0 && lastopcode.count !== 0))) {
                        // Skip this count, do nothing
                    }
                    else {
                        min = Math.min(min, c);
                        max = Math.max(max, c);
                        rawcounts.push(c);
                    }
                }
                else {  // Unreachable opcode
                    if (c !== 0) {
                        console.log("WARNING: unreachable opcode with non-0 count");
                        console.log(pc, opcode.count, opcode.assembly);
                    }
                    
                    rawcounts.push(-1);
                }

                lastopcode = opcode;
            }

            var counts;

            
            if (min === max && min >=0) {      // Special case: all lines are same
                counts = [min];  
            }
            else if (rawcounts.length === 1 && rawcounts[0] === -1) {
                // A single unreachable opcode.  If it is a stop opcode, then
                // this isn't really a dead line and should be treated as an
                // insignificant line instead.
                if (this.opcodes[Object.keys(this.opcodes)[0]].assembly === "stop")
                    counts = [];
            }
            else {
                rawcounts.sort(function(a,b) { return a-b; });  // Numerical order
                
                // Remove duplicates so only the unique counts are listed here
                var counts = [];
                counts[0] = rawcounts[0];
                for(var i = 1, j = 0; i < rawcounts.length; i++) {
                    if (rawcounts[i] === counts[j]) continue;
                    counts[++j] = rawcounts[i];
                }
            }            
            this._counts = counts;
        }

        return this._counts;
    };

    // Return coverage for this line.
    // One of the strings "full", "some", "none", "dead" or ""
    Line.prototype.coverage = function() {
        var counts = this.counts();
        // We return "" if the code should be treated as insignificant code
        // like comments and whitespace.  This happens when there is a single
        // unreachable stop opcode
        if (counts.length === 0) return "";

        if (counts[0] > 0) return "full";
        if (counts.length === 1) {
            if (counts[0] === 0) return "none";
            if (counts[0] === -1) return "dead";
        }
        return "some";
    };

    return Line;
}());

var File = (function() {
    function File(name) {
        this.name = name;
        this.lines = {};
    }

    File.prototype.line = function(linenum) {
        if (!this.lines[linenum]) {
            this.lines[linenum] = new Line(this, linenum);
        }
        return this.lines[linenum];
    };

    File.prototype.coverage = function() {
        var covered = 0, partial = 0, uncovered = 0, dead = 0;

        for(var linenum in this.lines) {
            var line = this.lines[linenum];
            switch(line.coverage()) {
            case "full": covered++; break;
            case "some": partial++; break;
            case "none": uncovered++; break;
            case "dead": dead++; break;
            case "": // do nothing in this case
            }
        }

        return [covered, partial, uncovered, dead];
    };

    // Return the coverage class for line n of the specified file.
    // Lines that don't have executable code will return an empty string.
    File.prototype.coverageClass = function(n) {
        if (n in this.lines) 
            return " " + this.lines[n].coverage();
        return "";
    };

    // Return the profile class for line n.  This will be based on the 
    // base-10 logarithm of the number of executions
    File.prototype.profileClass = function(n) {
        if (!(n in this.lines)) return "";
        var counts = this.lines[n].counts();
        var count = counts[counts.length-1];  // the last one is biggest
        return " p" + log(count);

        function log(x) {
            if (x <= 0) return 0;
            return Math.min(Math.floor(Math.log(x)/Math.LN10), 9);
        }
    };

    return File;
}());

// Read a stream of -D data and parse it. Interpret filenames relative to
// the specified directory.  If stream is stdin then any lines before the
// beginning of the -D data are printed to stdout.
function parseScripts(stream, callback) {
    var fragment = "";  // line fragments we haven't processed yet
    var scripts = [];   // Array of Script objects that hold the data
    var scriptMap = {}; // String->Script map for detecting duplicate scripts

    stream.on('data', function(chunk) {
        // Add any pending fragment to this chunk and break into lines
        var lines = (fragment + chunk).split("\n");
        
        // The last element of the array is an unterminated line
        fragment = lines.pop();
        
        // Now process the complete lines we got
        lines.forEach(processLine);
    });

    stream.on('end', function() {
        if (fragment != "") processLine(fragment);

        if (scripts.length === 0) {
            console.log("CoverMonkey: No coverage data to process.\n" +
                        "CoverMonkey: Are you using a debug build of spidermonkey?");
            process.exit(0);
        }

        callback(scripts);
    });

    var inscript = false; // Are we collecting a script or just echoing lines?
    var scriptlines;

    function processLine(dataline) {
        if (inscript) {
            scriptlines.push(dataline);
            if (dataline.match(SCRIPT_END)) {
                // Skip initial dummy script
                if (scriptlines[0] !== "--- SCRIPT (null):0 ---") {
                    var script = new Script(scriptlines);
                    var string = script.toString();

                    var existingScript = scriptMap[string];
                    if (existingScript) {
                        // We've seen this script before
                        existingScript.addCounts(script);
                    }
                    else {
                        scripts.push(script);
                        scriptMap[string] = script;
                        script.checkReachability();
                    }
                }
                
                scriptlines = null;
                inscript = false;
            }
        }
        else {
            if (dataline.match(SCRIPT_START)) {
                inscript = true;
                scriptlines = [ dataline ];
            }
            else if (stream === process.stdin) {
                console.log(dataline);
            }
        }
    }        
}


// Analyize the input and generate the output
function analyzeAndReportCoverage(scripts) {
    var data = {};

    // Convert the array of Script objects to an object mapping filenames
    // to File objects
    scripts.forEach(function(script) {
        var filename = script.filename;
        if (!(filename in data)) {
            data[filename] = new File(filename);
        }
        var file = data[filename];

        script.opcodes.forEach(function(opcode) {
            file.line(opcode.srcline).addOpcode(script.name + ":" + opcode.pc,
                                                opcode);
        });
    });


    // If no targets were specified, use all known files as targets
    if (options.targets.length === 0) { 
        for(filename in data) {
            // -D outputs a "(null)" script for the toplevel
            if (path.basename(filename) === "(null)") continue;
            options.targets.push(filename);
        }
        options.targets.sort();         // Alphabetially
    }

    // Now loop through the targets and output coverage data for each one
    // Unless the -q option was used
    if (!options.quiet) {

        if (!options.percent) {
            console.log("%s|%s|%s|%s|%s|%s",
                        pad.center("File", 20),
                        pad.center("Sloc", 5),
                        pad.center("Covered", 12),
                        pad.center("Partial", 12),
                        pad.center("Uncovered", 12),
                        pad.center("Dead", 12));
            console.log("------------------------------------------------------------------------------");
                        
        }

        options.targets.forEach(function(target, index) {
            var file = data[target];

            // If file is null here look for a file name with the same basename
            // And alter the target in the array
            if (!file) {
                target = path.basename(target);

                for(var filename in data) {
                    if (path.basename(filename) === target) {
                        target = filename;
                        file = data[filename];
                        options.targets[index] = target;
                        break;
                    }
                }
                if (!file) {
                    console.warn("Unknown target file %s", target);
                    return; 
                }
            }

            var coverage = file.coverage();
            var covered = coverage[0];
            var partial = coverage[1];
            var uncovered = coverage[2];
            var dead = coverage[3];
            var total = covered + partial + uncovered + dead;

            if (options.percent || covered === total) {
                console.log("%s: %s%", target, percent(covered/total));
            }
            else {
                console.log("%s|%s|%s %s%|%s %s%|%s %s%|%s %s%",
                            pad.right(target, 20),
                            pad.right(total, 5),
                            pad.right(covered, 5),
                            pad.right(percent(covered/total), 5),
                            pad.right(partial, 5),
                            pad.right(percent(partial/total), 5),
                            pad.right(uncovered, 5),
                            pad.right(percent(uncovered/total), 5),
                            pad.right(dead, 5),
                            pad.right(percent(dead/total), 5));

/*
                console.log("%s: %s%\n\t" +
                            "significant lines: %d\n\t" +
                            "          covered: %d (%s%)\n\t" +
                            "partially covered: %d (%s%)\n\t" +
                            "        uncovered: %d (%s%)\n\t" +
                            "             dead: %d (%d%)",
                            target, percent(covered/total),  total,
                            covered, percent(covered/total),
                            partial, percent(partial/total),
                            uncovered, percent(uncovered/total),
                            dead, percent(dead/total));
*/
            }

            if (options.listlines) {
                for(linenum in file.lines) {
                    var line = file.lines[linenum];
                    var msg = null;
                    switch(line.coverage()) {
                    case 'some':
                        msg = "partially covered";
                        break;
                    case 'none':
                        msg = "uncovered";
                        break;
                    case 'dead':
                        msg = "unreachable";
                        break;
                    }
                    if (msg) console.log("%s:%d: %s", file.name, linenum, msg);
                }
                
            }
        });
    }

    if (options.htmlfile || options.openhtml) {
        // If no html filename specified, use a temporary file
        // XXX: this may be MacOS dependent.  Surprisingly, Node
        // doesn't have temporary path creation utility.
        if (options.openhtml && !options.htmlfile) {
            options.overwrite = false;
            options.htmlfile = process.env.TMPDIR + "Coverage" +
                Math.floor(Math.random()*100000000) + ".html";
        }

        outputHTML(data, function() {
            if (options.openhtml) {
                require("child_process").spawn("open", [options.htmlfile]);
            }
        });
    }
}

// Return a string of n spaces where n is <= 50;
function pad(n) { return pad.spaces.substring(0,n); }
pad.spaces = "                                                  ";

// Return the string s centered in a field n characters wide
pad.center = function(s, n) {
    s = String(s);
    if (s.length >= n) return s;
    var left = Math.floor((n - s.length)/2),
        right = n - s.length - left;
    return pad(left) + s + pad(right);
};
// Return the string s right-justified in a field n characters wide
pad.right = function(s, n) {
    s = String(s);
    if (s.length >= n) return s.substring(s.length-n);
    return pad(n - s.length) + s;
}
// Return the string s left-justified in a field n characters wide
pad.left = function(s, n) {
    s = String(s);
    if (s.length >= n) return s.substring(0,n);
    return s + pad(n - s.length);
}


// Write an HTML file of coverage information.
// Invoke the callback when the file has been written.
function outputHTML(files, callback) {
    if (!options.htmlfile) return;

    if (!options.overwrite && path.existsSync(options.htmlfile)) {
        console.log("%s exists: no HTML output written. Use -f to force overwrite",
                    options.htmlfile);
        return;
    }

    var out = fs.createWriteStream(options.htmlfile);
    out.on("close", function() { callback(); });

    function printf(fmt) {
        out.write(util.format.apply(util, Array.prototype.slice.call(arguments,0)));
    }
    
    printf('<html><head>\n' +
           '<title>CoverMonkey Code Coverage</title>\n' + 
           '<style type="text/css">\n' +
           '.line {white-space: pre; font-family: monospace; font-weight: bold; padding:1px;}\n' +
           '.full {background-color: #fff}\n' +  // white for full coverage
           '.none {background-color: #faa}\n' +  // red for no coverage
           '.some {background-color: #ffa}\n' +  // yellow for partial coverage
           '.dead {background-color: #fca}\n' +  // orange for dead code
           '.p0 {color:#000;}\n' +
           '.p1 {color:#200;}\n' +
           '.p2 {color:#400;}\n' +
           '.p3 {color:#600;}\n' +
           '.p4 {color:#800;}\n' +
           '.p5 {color:#a00;}\n' +
           '.p6 {color:#c00;}\n' +
           '.p7 {color:#e00;}\n' +
           '.p8 {color:#f00;}\n' +
           '.p9 {color:#f00;}\n' +
           'table {border-collapse:collapse;}\n' +
           'td, th {border:solid black 1px; padding:3px 5px 3px 5px;}\n' +
           'th {background-color:rgba(0,0,0,0.1)}\n' +
           '.num {float:left; font-weight:bold; text-align:right; margin-right:1%; width:4%; text-decoration:none; color:inherit;}\n' +
           '.type {float:right; font-weight:bold; font-size:smaller; text-align:left; margin-left:1%; width:9%; }\n' +
           '.ops { margin-left: 5%; padding-left: 10px; }\n' +
           '.hidden { display:none; }\n' +
           '</style>\n' +
           '<script>\n' +
           'document.addEventListener("click", clickHandler, true);\n' +
           'function clickHandler(e) {\n' +
           '    if (e.target.classList.contains("num")) return;\n' +
           '    for(var elt = e.target; elt; elt = elt.parentNode) {\n' +
           '        if (elt.classList.contains("line")) {\n' +
           '            elt = elt.getElementsByTagName("table")[0];\n' +
           '            if (elt) elt.classList.toggle("hidden");\n' +
           '            return;\n' +
           '        }\n' +
           '    }\n' +
           '}\n' +
           '</script>\n' +
           '</head>\n' +
           '<body>\n' +
           '<h1>CoverMonkey Code Coverage</h1>\n'
          );

    
    printf('<table>\n<tr><th>Source File<th>Executable Lines' +
           '<th>Covered<th>Partial<th>Uncovered<th>Dead</tr>\n');

    // Summary table
    options.targets.forEach(function(target) {
        var file = files[target];
        var coverage = file.coverage();
        var covered = coverage[0];
        var partial = coverage[1];
        var uncovered = coverage[2];
        var dead = coverage[3];
        var total = covered + partial + uncovered + dead;
        printf('<tr><td><a href="#%s">%s</a><td>%d' +
               '<td>%d (%d%)<td>%d (%d%)<td>%d (%d%)<td>%d (%d%)</tr>\n',
               target, target, total, 
               covered, percent(covered/total),
               partial, percent(partial/total),
               uncovered, percent(uncovered/total),
               dead, percent(dead/total));
        
    });

    printf("</table>\n");

    // Now output the annotated source code of each target
    options.targets.forEach(function(target) {
        var file = files[target];
        var srclines = fs.readFileSync(target, "utf8").split("\n");

        printf('<a name="%s"><h2>%s</h2></a>\n', target, target);
        srclines.forEach(function(srcline, linenum) {
            linenum += 1; // line numbers are 1-based, not 0-based
            var linedata = file.lines[linenum];
            var cov = file.coverageClass(linenum);
            var c = "line" + cov + file.profileClass(linenum);
            if (srcline === "") srcline = " "; // To make the HTML format right.
            if (cov) {
                if (cov === " full") {
                    var counts = linedata.counts();
                    cov = "// " + counts.join(",");
                }
                else
                    cov = "//" + cov;
            }
            printf('<div id="%s:%d" class="%s"><a href="#%s:%d" class="num">%d</a>' +
                   '<span class="type">%s</span>%s',
                   target, linenum, c, target, linenum, linenum, cov, srcline);

            if (options.outputops && linedata) {
                printf('<table class="ops hidden">');
                printf('<tr><th>Function @<th>PC<th>#<th>Instruction</tr>');
                for(pc in linedata.opcodes) {
                    var opcode = linedata.opcodes[pc];
                    var idx = pc.lastIndexOf(":");
                    printf("<tr><td>%s<td>%s<td>%d<td>%s</tr>",
                           pc.substring(0,idx),
                           pc.substring(idx+1),
                           opcode.count,
                           opcode.assembly);
                }
                printf("</table>");
            }
            printf("</div>\n");  // close the line div
        });
    });
    
    printf("</body>\n</html>\n");
    out.end();
}

function percent(x) { return (x*100).toFixed(1); }
